#!/bin/bash

REPO_NAME=${1:-$(basename "$(pwd)")}
USERNAME=$(gh api user --jq .login 2>/dev/null)
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")

echo "💦 PUSHING HARD (PRIVATE + BRANCH-AWARE) into GitHub as $USERNAME, repo: $REPO_NAME"
echo "🌿 Current branch: $CURRENT_BRANCH"

# ───────────────────────────────────── Branding prompt
read -p "🌟 Do you want to include the sexy PushHard™ README branding? (y/N): " INCLUDE_BRANDING
INCLUDE_BRANDING=$(echo "$INCLUDE_BRANDING" | tr '[:upper:]' '[:lower:]')

# ───────────────────────────────────── README
if [[ "$INCLUDE_BRANDING" == "y" || "$INCLUDE_BRANDING" == "yes" ]]; then
cat <<EOL > README.md
# 🚀 $REPO_NAME

> Built with sweat, swagger, and a whole lotta PushHard™ 💦
> _(Auto-generated by \`pushhard.sh\`)_

---

## 🔥 What Is This?
Legendary repo. Precision, speed, zero tolerance for git fuckery.

---

## 🧠 Features
- 🔒 Private by default
- 🧼 Auto-untracks garbage (.env, node_modules)
- 🐙 Instantly deploys to GitHub
- 🔁 Handles diverged branches like a Git therapist
- 💥 README, .gitignore, first commit: **done**
EOL
else
  echo "# $REPO_NAME" > README.md
fi
touch README.md            # ensure mtime updated

# ───────────────────────────────────── .gitignore
cat <<EOL > .gitignore
.env
.env.local
node_modules/
.DS_Store
dist/
.next/
out/
build/
coverage/
*.log
*.sqlite
EOL

# ───────────────────────────────────── Clean tracked trash
git rm -r --cached node_modules/ dist/ .next/ out/ build/ coverage/ .env .env.local .DS_Store 2>/dev/null

# ───────────────────────────────────── Init repo if absent
if [ ! -d .git ]; then
  echo "🧬 No Git found — initializing…"
  git init
  git checkout -b "$CURRENT_BRANCH"
  git add .
  git commit -m "💥 pushhard: first commit, repo cleansed"
else
  echo "📦 Git repo already exists. Continuing…"
fi

# ───────────────────────────────────── Create repo if no origin
if ! git remote | grep -q origin; then
  echo "🔒 Creating PRIVATE GitHub repo via gh CLI…"
  gh repo create "$REPO_NAME" --private --source=. --remote=origin --push
else
  echo "🔁 Remote already exists. Checking for updates…"

  # ───── Ensure origin URL belongs to current user
  REMOTE_URL=$(git remote get-url origin 2>/dev/null)
  if [[ "$REMOTE_URL" != *"$USERNAME"* ]]; then
    echo "⚠️  origin is $REMOTE_URL — repointing to git@github.com:$USERNAME/$REPO_NAME.git"
    git remote set-url origin git@github.com:$USERNAME/$REPO_NAME.git
  fi

  git fetch origin "$CURRENT_BRANCH" 2>/dev/null
  STATUS=$(git status -sb)

  if [[ $STATUS == *"ahead"* && $STATUS == *"behind"* ]]; then
    echo "❌ Branch has diverged. Manual fix needed. PushHard aborted."
    exit 1
  elif [[ $STATUS == *"behind"* ]]; then
    echo "📥 Behind remote. Pulling updates…"
    git pull origin "$CURRENT_BRANCH" --rebase
  fi

  echo "🔍 Git status before commit:"
  git status

  # ───── Stage everything
  git add -A

  if ! git diff --cached --quiet; then
    echo "📦 Committing updates…"
    git commit -m "🔁 pushhard: update"
    git push origin "$CURRENT_BRANCH"
  else
    echo "🟢 Nothing new to commit. Checking README just in case…"
    git add README.md
    if ! git diff --cached --quiet; then
      echo "📄 README.md was updated — committing forcefully."
      git commit -m "📝 pushhard: forced README update"
      git push origin "$CURRENT_BRANCH"
    else
      echo "✔️  Confirmed: no detectable changes. Repo fully synced."
    fi
  fi
fi

echo "✅ Private repo is live at: https://github.com/$USERNAME/$REPO_NAME/tree/$CURRENT_BRANCH"
echo "🔒 PushHard complete. GitHub respected. Swagger intact."
